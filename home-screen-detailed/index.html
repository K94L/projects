<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>House Screen Detailed</title>
    <link rel="stylesheet" href="../assets/main.css" />
    <link rel="icon" href="../assets/favicon.svg" type="image/svg+xml" />
  </head>
  <body>
    <div class="page">
      <header>
        <a href="../" class="logo">
          <span class="logo-badge">KL</span>
          <span>Back</span>
        </a>
        <div id="fetch-status" class="status-pill loading">
          <span class="dot"></span>
          <span>Fetching</span>
        </div>
      </header>

      <div class="hero-clock">
        <div class="time" id="clock-time">--:--</div>
        <div class="date" id="clock-date">
          <span>loading date</span>
        </div>
        <div class="weather-summary" id="weather-summary">
          <span id="weather-icon" aria-label="Today‚Äôs weather" class="summary-icon">--</span>
          <span id="temp-range">--¬∞ / --¬∞</span>
        </div>
      </div>

      <div class="dashboard stacked">
        <section class="departures-card">
          <div class="panel-title">üöá L√∏ren Metro</div>
          <div id="loren-west" class="departures-list"></div>
        </section>

        <section class="departures-card">
          <div class="panel-title">üöá Sinsen Metro</div>
          <div id="sinsen-list" class="departures-list"></div>
        </section>

        <section class="weather-card">
          <div class="panel-title">üå§Ô∏è Weather in Oslo</div>
          <div id="weather-grid" class="weather-grid" style="margin-top: 12px"></div>
        </section>
      </div>
    </div>

    <script>
      const STOP_IDS = {
        loren: 'NSR:StopPlace:63284',
        sinsen: 'NSR:StopPlace:61268',
      };

      const formatTime = (dateStr) => {
        const date = new Date(dateStr);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      };

      const formatTimeHm = (dateStr) => {
        const date = new Date(dateStr);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      };

      const WALK_OFFSET_MIN = 7;

      const withinNextHour = (dateStr) => {
        const t = new Date(dateStr).getTime();
        const now = Date.now();
        const hour = 60 * 60 * 1000;
        return t >= now && t <= now + hour;
      };

      const addMinutesIso = (dateStr, minutes) => {
        const d = new Date(dateStr);
        d.setMinutes(d.getMinutes() + minutes);
        return d.toISOString();
      };

      const walkByTime = (dateStr) => {
        const d = new Date(dateStr);
        if (Number.isNaN(d.getTime())) return null;
        d.setMinutes(d.getMinutes() - WALK_OFFSET_MIN);
        return d.toISOString();
      };

      const walkByFromClock = (clockTime) => {
        if (!clockTime) return null;
        const parts = clockTime.split(':');
        if (parts.length < 2) return null;
        const now = new Date();
        const d = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate(),
          Number(parts[0]),
          Number(parts[1])
        );
        if (Number.isNaN(d.getTime())) return null;
        d.setMinutes(d.getMinutes() - WALK_OFFSET_MIN);
        return d.toISOString();
      };

      const countdownLabel = (iso) => {
        const target = new Date(iso).getTime();
        if (Number.isNaN(target)) return '';
        const diff = target - Date.now();
        const absMs = Math.abs(diff);
        const totalSec = Math.floor(absMs / 1000);
        const mins = Math.floor(totalSec / 60);
        const secs = totalSec % 60;
        const pad = (n) => String(n).padStart(2, '0');

        if (diff <= 0) {
          if (totalSec === 0) return 'now';
          if (mins === 0) return `${secs} sec ago`;
          return `${mins}:${pad(secs)} ago`;
        }

        if (mins === 0) return `in ${secs} sec`;
        return `in ${mins}:${pad(secs)}`;
      };

      const FALLBACK_DEPARTURES = {
        lorenWest: [
          {
            line: '4',
            destination: 'Bergkrystallen',
            platform: '2',
            time: '13:41',
            delayMinutes: 2,
            walkBy: walkByFromClock('13:41'),
          },
          {
            line: '5',
            destination: 'Ringen',
            platform: '2',
            time: '13:54',
            delayMinutes: 1,
            walkBy: walkByFromClock('13:54'),
          },
        ],
        sinsen: [
          { line: '5', destination: 'Sognsvann', platform: '2', time: '13:52', delayMinutes: 0 },
          { line: '5', destination: 'Sognsvann', platform: '2', time: '14:10', delayMinutes: 0 },
        ],
      };

      const FALLBACK_WEATHER = [
        { label: '13:00', temp: -1, icon: '‚òÅÔ∏è', precip: 0.0, symbolCode: 'cloudy' },
        { label: '14:00', temp: 0, icon: '‚òÅÔ∏è', precip: 0.0, symbolCode: 'cloudy' },
        { label: '15:00', temp: 0, icon: '‚òÅÔ∏è', precip: 0.0, symbolCode: 'cloudy' },
        { label: '16:00', temp: -1, icon: '‚òÅÔ∏è', precip: 0.0, symbolCode: 'cloudy' },
        { label: '17:00', temp: -1, icon: '‚òÅÔ∏è', precip: 0.0, symbolCode: 'cloudy' },
        { label: '18:00', temp: -1, icon: '‚òÅÔ∏è', precip: 0.0, symbolCode: 'cloudy' },
      ];

      const diffMinutes = (expected, aimed) => {
        const e = new Date(expected).getTime();
        const a = new Date(aimed).getTime();
        return Math.round((e - a) / 60000);
      };

      const delayLabel = (delta) => {
        if (delta <= 0) return { text: 'on time', cls: 'ok' };
        if (delta <= 2) return { text: `+${delta} min`, cls: 'warn' };
        return { text: `+${delta} min`, cls: 'bad' };
      };

      const setStatus = (state, label) => {
        const el = document.getElementById('fetch-status');
        if (!el) return;
        el.classList.remove('live', 'error', 'loading');
        el.classList.add(state);
        el.querySelector('span:nth-child(2)').textContent = label;
      };

      const symbolIcon = (code) => {
        if (!code) return '‚òÅÔ∏è';
        if (code.includes('thunder')) return '‚õàÔ∏è';
        if (code.includes('sleet')) return 'üå®Ô∏è';
        if (code.includes('rain')) return 'üåßÔ∏è';
        if (code.includes('snow')) return 'üå®Ô∏è';
        if (code.includes('cloud')) return '‚òÅÔ∏è';
        if (code.includes('sun') || code.includes('clearsky')) return '‚òÄÔ∏è';
        return '‚òÅÔ∏è';
      };

      const isSummerMonth = (date) => {
        const m = date.getMonth();
        return m >= 4 && m <= 7; // May‚ÄìAug
      };

      const isNightTime = (date) => {
        const hour = date.getHours();
        const cutoff = isSummerMonth(date) ? 21 : 18;
        return hour >= cutoff || hour < 6;
      };

      const iconWithNight = (symbolCode, date, forceClear = false) => {
        const isClear = forceClear || iconSeverity(symbolCode || '') <= 1;
        if (isClear && isNightTime(date)) return 'üåô';
        return symbolIcon(symbolCode);
      };

      const fetchDepartures = async (stopId, limit = 40) => {
        const query = `
          {
            stopPlace(id: "${stopId}") {
              name
              estimatedCalls(numberOfDepartures: ${limit}) {
              expectedDepartureTime
              aimedDepartureTime
              destinationDisplay { frontText }
              quay { publicCode }
              serviceJourney {
                id
                journeyPattern { line { name publicCode transportMode } }
                estimatedCalls {
                  quay { stopPlace { id name } }
                    expectedArrivalTime
                    expectedDepartureTime
                    aimedArrivalTime
                  }
                }
              }
            }
          }
        `;

        const res = await fetch('https://api.entur.io/journey-planner/v3/graphql', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'ET-Client-Name': 'kl-home-screen',
          },
          body: JSON.stringify({ query }),
        });

        if (!res.ok) throw new Error('Ruter API error');
        const json = await res.json();
        return json.data?.stopPlace?.estimatedCalls ?? [];
      };

      const renderDepartures = (containerId, rows, noticeText, earliestByLabel, usedEarliest) => {
        const el = document.getElementById(containerId);
        el.innerHTML = '';
        if (!rows.length) {
          el.innerHTML = `<div class="badge">${noticeText || 'No departures right now'}</div>`;
          return;
        }

        if (noticeText) {
          const note = document.createElement('div');
          note.className = 'badge';
          note.style.marginBottom = '8px';
          note.textContent = noticeText;
          el.appendChild(note);
        }

        rows.forEach((item) => {
          const delay = delayLabel(item.delayMinutes);
          const row = document.createElement('div');
          row.className = 'departure-row';

          const departureCard = `
            <div class="departure-card">
              <div class="line-pill">${item.line}</div>
              <div class="departure-main">
                <div class="destination">${item.destination}</div>
                <div class="platform">Track ${item.platform || '‚Äì'}</div>
                ${
                  item.sinsenArrival
                    ? `<div class="platform" style="color: var(--success)">Arrives Sinsen ~${item.sinsenArrival}</div>`
                    : ''
                }
                ${
                  item.walkBy
                    ? `<div class="platform walk-deadline" data-target="${item.walkBy}">
                        <span>Leave by ${formatTime(item.walkBy)}</span>
                        <span class="walk-countdown" data-target="${item.walkBy}">(${countdownLabel(item.walkBy)})</span>
                      </div>`
                    : ''
                }
              </div>
              <div class="time-col">
                <div class="departure-time">${item.time}</div>
                <div class="delay ${delay.cls}">${delay.text}</div>
                ${
                  item.catchLabel
                    ? `<div class="catch-diff ${item.catchClass || ''}">${item.catchLabel}</div>`
                    : ''
                }
              </div>
            </div>
          `;

          let arrivalsCards = '';
          if (item.arrivals && item.arrivals.length) {
            const arrivalsSlice = item.arrivals.slice(0, 3);
            arrivalsCards = arrivalsSlice
              .map((a) => {
                const ms = new Date(a.time).getTime();
                const isEarliest = earliestByLabel[a.label] === ms && !usedEarliest[a.label];
                if (isEarliest) usedEarliest[a.label] = true;
                return `
                  <div class="arrival-card">
                    <div class="arrival-station">${a.label}</div>
                    <div class="arrival-meta">
                      <span>Arrival</span>
                      <span class="arrival-time ${isEarliest ? 'earliest' : ''}">${formatTimeHm(a.time)}</span>
                    </div>
                    <div class="arrival-meta">
                      <span>Travel time</span>
                      <span>${a.delta} min</span>
                    </div>
                  </div>
                `;
              })
              .join('');
            const missing = 3 - arrivalsSlice.length;
            if (missing > 0) {
              arrivalsCards += '<div class="arrival-card"></div>'.repeat(missing);
            }
          } else {
            arrivalsCards = `
              <div class="arrival-card"><div class="arrival-header"><span>No times</span></div></div>
              <div class="arrival-card"></div>
              <div class="arrival-card"></div>
            `;
          }

          row.innerHTML = `${departureCard}${arrivalsCards}`;
          el.appendChild(row);
        });
      };

      const loadDepartures = async () => {
        try {
          setStatus('loading', 'Updating‚Ä¶');
          const loren = await fetchDepartures(STOP_IDS.loren);
          const sinsen = await fetchDepartures(STOP_IDS.sinsen, 80);

          const importantStops = [
            { ids: ['NSR:StopPlace:3990', 'NSR:StopPlace:58366'], label: 'Jernbanetorget' },
            { ids: ['NSR:StopPlace:4067', 'NSR:StopPlace:58404'], label: 'Nationaltheatret' },
            { ids: ['NSR:StopPlace:4452', 'NSR:StopPlace:58381'], label: 'Majorstuen' },
          ];

          const extractArrivals = (serviceJourney, startExpected) => {
            if (!serviceJourney?.estimatedCalls?.length || !startExpected) return [];
            const startMs = new Date(startExpected).getTime();
            if (Number.isNaN(startMs)) return [];
            return importantStops
              .map((stop) => {
                const candidates = serviceJourney.estimatedCalls
                  .filter((c) => stop.ids.includes(c.quay?.stopPlace?.id) && c.expectedArrivalTime)
                  .map((c) => ({
                    time: c.expectedArrivalTime,
                    ms: new Date(c.expectedArrivalTime).getTime(),
                  }))
                  .filter((c) => !Number.isNaN(c.ms))
                  .sort((a, b) => a.ms - b.ms);

                if (!candidates.length) return null;

                const chosen = candidates.find((c) => c.ms >= startMs) || candidates[0];
                let diffMs = chosen.ms - startMs;

                // Wrap around midnight if the best match is before departure on the same service day.
                if (diffMs < 0) diffMs += 24 * 60 * 60 * 1000;

                const diffMin = Math.round(diffMs / 60000);
                // Guard against bogus long durations (e.g., if the API jumps a day ahead).
                if (diffMin > 240) return null;

                return {
                  label: stop.label,
                  time: chosen.time,
                  delta: diffMin,
                };
              })
              .filter(Boolean);
          };

          const mapCalls = (calls, filterFn, opts = {}) => {
            const { useNextHour = true } = opts;
            const base = calls.filter(filterFn).map((call) => {
              const line = call.serviceJourney?.journeyPattern?.line;
              return {
                line: line?.publicCode || '?',
                destination: call.destinationDisplay?.frontText || 'Unknown',
                platform: call.quay?.publicCode || '',
                time: formatTime(call.expectedDepartureTime),
                delayMinutes: diffMinutes(call.expectedDepartureTime, call.aimedDepartureTime),
                aimed: call.aimedDepartureTime,
                expected: call.expectedDepartureTime,
                serviceJourneyId: call.serviceJourney?.id || '',
                arrivals: extractArrivals(call.serviceJourney, call.expectedDepartureTime),
              };
            });

            const sorted = base.sort((a, b) => new Date(a.aimed) - new Date(b.aimed));
            const nextHour = useNextHour ? sorted.filter((c) => withinNextHour(c.expected)) : [];
            const chosen =
              useNextHour && nextHour.length > 0
                ? nextHour
                : sorted.slice(0, 12);

            return chosen;
          };

          const lorenRows = mapCalls(
            loren,
            (c) =>
              c.serviceJourney?.journeyPattern?.line?.transportMode === 'metro' &&
              ['1', '2', '3', '4', '5'].includes(c.serviceJourney.journeyPattern.line.publicCode)
          );

          const lorenWest = lorenRows
            .filter((r) => r.platform === '2')
            .map((r) => ({
              ...r,
              sinsenArrival: undefined,
              walkBy: walkByTime(r.expected) || walkByFromClock(r.time),
            }))
            .slice(0, 4);

          const sinsenRows = mapCalls(
            sinsen,
            (c) =>
              c.serviceJourney?.journeyPattern?.line?.transportMode === 'metro' &&
              c.serviceJourney.journeyPattern.line.publicCode === '5' &&
              c.quay?.publicCode === '2',
            { useNextHour: false }
          );

          const firstLorenWest = lorenWest.length ? new Date(lorenWest[0].expected).getTime() : null;
          const sinsenCutoff = firstLorenWest !== null ? firstLorenWest - 4 * 60 * 1000 : null;

          const sinsenFiltered =
            sinsenCutoff !== null
              ? sinsenRows.filter((r) => new Date(r.expected).getTime() >= sinsenCutoff)
              : sinsenRows;

          const sinsenLimited = sinsenFiltered.slice(0, 4);

          const annotateSinsen = (rows, lorenWestRows) => {
            if (!rows.length) return rows;
            const baseline = lorenWestRows.length ? lorenWestRows : [];
            return rows.map((row) => {
              let chosen = null;
              let diffMs = 0;

              if (row.serviceJourneyId) {
                chosen = baseline.find((l) => l.serviceJourneyId && l.serviceJourneyId === row.serviceJourneyId);
                if (chosen) diffMs = new Date(row.expected) - new Date(chosen.expected);
              }

              if (!chosen && baseline.length) {
                let best = { abs: Infinity, diff: 0, row: null };
                baseline.forEach((l) => {
                  const d = new Date(row.expected) - new Date(l.expected);
                  const abs = Math.abs(d);
                  if (abs < best.abs) best = { abs, diff: d, row: l };
                });
                if (best.row) {
                  chosen = best.row;
                  diffMs = best.diff;
                }
              }

              if (!chosen) return row;

              const diffMin = Math.round(diffMs / 60000);
              const label =
                diffMin === 0
                  ? 'Same time'
                  : diffMin > 0
                    ? `+${diffMin} min after`
                    : `${Math.abs(diffMin)} min before`;

              return {
                ...row,
                catchLabel: label,
                catchClass: diffMin >= 0 ? 'ok' : 'late',
              };
            });
          };

          const sinsenAnnotated = annotateSinsen(sinsenLimited, lorenWest);

          // Earliest arrivals across both L√∏ren and Sinsen
          const earliestByLabel = {};
          [...lorenWest, ...sinsenAnnotated].forEach((r) => {
            (r.arrivals || []).forEach((a) => {
              const ms = new Date(a.time).getTime();
              if (Number.isNaN(ms)) return;
              if (!earliestByLabel[a.label] || ms < earliestByLabel[a.label]) {
                earliestByLabel[a.label] = ms;
              }
            });
          });
          const usedEarliest = {};

          renderDepartures(
            'loren-west',
            lorenWest.length ? lorenWest : FALLBACK_DEPARTURES.lorenWest,
            lorenWest.length ? '' : 'Showing demo data ‚Äì no live data in the next hour',
            earliestByLabel,
            usedEarliest
          );
          renderDepartures(
            'sinsen-list',
            sinsenAnnotated.length ? sinsenAnnotated : FALLBACK_DEPARTURES.sinsen,
            sinsenAnnotated.length ? '' : 'Showing demo data ‚Äì no live data in the next hour',
            earliestByLabel,
            usedEarliest
          );

          setStatus('live', 'Live');
          updateCountdowns();
        } catch (err) {
          console.error(err);
          setStatus('error', 'No live data');
          renderDepartures('loren-west', FALLBACK_DEPARTURES.lorenWest, 'Could not fetch Ruter data ‚Äì showing demo');
          renderDepartures('sinsen-list', FALLBACK_DEPARTURES.sinsen, 'Could not fetch Ruter data ‚Äì showing demo');
          updateCountdowns();
        }
      };

      const fetchWeather = async () => {
        const res = await fetch(
          'https://api.met.no/weatherapi/locationforecast/2.0/compact?lat=59.9295&lon=10.7913'
        );
        if (!res.ok) throw new Error('Weather fetch failed');
        const json = await res.json();
        return json.properties?.timeseries ?? [];
      };

      const filterUntilMidnight = (timeseries) => {
        const now = new Date();
        const midnight = new Date(now);
        midnight.setHours(24, 0, 0, 0);
        const nowMs = now.getTime();
        return timeseries.filter((ts) => {
          const tsDate = new Date(ts.time);
          const t = tsDate.getTime();
          const sameHour =
            tsDate.getFullYear() === now.getFullYear() &&
            tsDate.getMonth() === now.getMonth() &&
            tsDate.getDate() === now.getDate() &&
            tsDate.getHours() === now.getHours();
          return (t >= nowMs || sameHour) && t <= midnight.getTime();
        });
      };

      const normalizeWeather = (timeseries) =>
        filterUntilMidnight(timeseries).map((ts) => {
          const date = new Date(ts.time);
          const temp = ts.data?.instant?.details?.air_temperature;
          const precip = Number(ts.data?.next_1_hours?.details?.precipitation_amount ?? 0);
          const symbolCode =
            ts.data?.next_1_hours?.summary?.symbol_code || ts.data?.next_6_hours?.summary?.symbol_code || '';
          return {
            label: date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            temp: Math.round(temp),
            precip,
            symbolCode,
            date,
          };
        });

      const iconSeverity = (code = '') => {
        const c = code.toLowerCase();
        if (c.includes('thunder')) return 5;
        if (c.includes('rain')) return 4;
        if (c.includes('sleet')) return 3.5;
        if (c.includes('snow')) return 3;
        if (c.includes('cloud')) return 2;
        if (c.includes('fair') || c.includes('clearsky') || c.includes('sun')) return 1;
        return 0;
      };

      const summarizeWeatherDay = (items) => {
        if (!items.length) return null;
        const temps = items.map((w) => w.temp).filter((t) => Number.isFinite(t));
        if (!temps.length) return null;
        const min = Math.min(...temps);
        const max = Math.max(...temps);
        const willRain = items.some((w) => Number(w.precip) > 0.1);
        const sortedBySeverity = [...items]
          .filter((w) => w.symbolCode)
          .sort((a, b) => iconSeverity(b.symbolCode) - iconSeverity(a.symbolCode));
        const worst = sortedBySeverity[0];
        const allClear = items.every((w) => iconSeverity(w.symbolCode || '') <= 1);

        return { min, max, willRain, worstSymbol: worst?.symbolCode || '', allClear };
      };

      const updateWeatherSummary = (summary) => {
        const rangeEl = document.getElementById('temp-range');
        const iconEl = document.getElementById('weather-icon');
        if (!summary || !rangeEl || !iconEl) return;
        rangeEl.textContent = `${summary.min}¬∞ / ${summary.max}¬∞`;
        const now = new Date();
        const worstIcon = iconWithNight(summary.worstSymbol || 'clearsky', now, summary.allClear);
        iconEl.textContent = worstIcon;
      };

      const resolveItemDate = (item) => {
        if (item.date) return new Date(item.date);
        const now = new Date();
        const [hh, mm] = String(item.label || '').split(':').map((p) => Number(p));
        return new Date(now.getFullYear(), now.getMonth(), now.getDate(), Number.isFinite(hh) ? hh : 0, Number.isFinite(mm) ? mm : 0);
      };

      const renderWeather = (items, noticeText) => {
        const grid = document.getElementById('weather-grid');
        grid.innerHTML = '';
        if (!items.length) {
          grid.innerHTML = `<div class="badge">${noticeText || 'No weather data'}</div>`;
          return;
        }

        if (noticeText) {
          const note = document.createElement('div');
          note.className = 'badge';
          note.style.marginBottom = '8px';
          note.textContent = noticeText;
          grid.appendChild(note);
        }

        items.forEach((item) => {
          const cellDate = resolveItemDate(item);
          const displayIcon = iconWithNight(item.symbolCode || '', cellDate, iconSeverity(item.symbolCode || '') <= 1);
          const cell = document.createElement('div');
          cell.className = 'weather-cell';
          cell.innerHTML = `
            <div class="weather-time">${item.label}</div>
            <div class="weather-temp">${item.temp}¬∞</div>
            <div class="weather-icon">${displayIcon}</div>
            <div class="weather-precip">${Number(item.precip).toFixed(1)} mm</div>
          `;
          grid.appendChild(cell);
        });
      };

      const loadWeather = async () => {
        try {
          const ts = await fetchWeather();
          const items = normalizeWeather(ts);
          const summary = summarizeWeatherDay(items);
          renderWeather(
            items.length ? items : FALLBACK_WEATHER,
            items.length ? '' : 'Showing demo weather ‚Äì no data'
          );
          updateWeatherSummary(summary || summarizeWeatherDay(FALLBACK_WEATHER));
          setStatus('live', 'Live');
        } catch (err) {
          console.error(err);
          setStatus('error', 'No live data');
          renderWeather(FALLBACK_WEATHER, 'Could not fetch weather ‚Äì showing demo');
          updateWeatherSummary(summarizeWeatherDay(FALLBACK_WEATHER));
        }
      };

      const tickClock = () => {
        const now = new Date();
        document.getElementById('clock-time').textContent = now.toLocaleTimeString([], {
          hour: '2-digit',
          minute: '2-digit',
        });
        document.getElementById('clock-date').textContent = now.toLocaleDateString('en-GB', {
          weekday: 'long',
          day: 'numeric',
          month: 'long',
        });
      };

      const updateCountdowns = () => {
        document.querySelectorAll('.walk-countdown').forEach((el) => {
          const target = el.getAttribute('data-target');
          if (!target) return;
          const label = countdownLabel(target);
          el.textContent = `(${label})`;
          const parent = el.closest('.walk-deadline');
          if (parent) {
            parent.classList.toggle('late', label.includes('ago'));
          }
        });
      };

      tickClock();
      setInterval(tickClock, 1000 * 30);
      loadDepartures();
      loadWeather();
      setInterval(loadDepartures, 1000 * 60);
      setInterval(loadWeather, 1000 * 60 * 10);
      setInterval(updateCountdowns, 1000);
      setInterval(loadWeather, 1000 * 60);
    </script>
  </body>
</html>

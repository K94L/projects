<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Market Crash Predictor</title>
    <script src="../local-env.js"></script>
    <link rel="stylesheet" href="../assets/main.css" />
    <link rel="icon" href="../assets/favicon.svg" type="image/svg+xml" />
  </head>
  <body>
    <div class="page">
      <header>
        <a href="../" class="logo">
          <span class="logo-badge">KL</span>
          <span>Projects</span>
        </a>
        <div class="pill" style="font-weight: 700; color: var(--accent)">Exploration build</div>
      </header>

      <main class="stack">
        <section class="card market-hero">
          <div class="market-hero__text">
            <h1 style="margin-top: 10px; margin-bottom: 12px">Market Crash Predictor</h1>
            <p>
              Simplified cockpit. Live VIX (VIXM) and Brent (CO1) from Twelve Data; USD/JPY newly wired.
            </p>
          </div>

          <div class="market-hero__panel">
            <div class="panel-title" style="margin-bottom: 6px">Risk dial</div>
            <div class="dial">
              <div class="dial__value" id="dial-value">--</div>
              <div class="dial__label" id="dial-label">Current composite probability</div>
              <div class="dial__bar">
                <div class="dial__bar-fill" id="dial-fill"></div>
              </div>
              <div class="dial__legend">
                <span>Calm</span>
                <span>Caution</span>
                <span>Stress</span>
              </div>
            </div>
          </div>
        </section>

        <section>
          <div class="section-header">
            <h2>Signals</h2>
            <div class="pill" id="last-updated">Updates every 30 seconds</div>
            <div class="pill" id="next-refresh">Next refresh in 30s</div>
          </div>
          <div id="crash-mode" class="status-pill">
            <span class="dot"></span>
            <span>Waiting for signals</span>
          </div>
          <div class="signal-list" id="signal-list"></div>
        </section>

      </main>
    </div>
    <script>
      const POLL_INTERVAL_MS = 300000; // 5 minutes to reduce API usage
      const ENDPOINT = '/api/market-signals';
      const LOCAL_TOKEN = typeof window !== 'undefined' ? window.TWELVE_DATA_KEY : null;
      // Treat only file:// as static so localhost can use local fetch and/or API route
      const IS_STATIC = typeof window !== 'undefined' && window.location.protocol === 'file:';
      let nextRefreshAt = Date.now() + POLL_INTERVAL_MS;

      const ZERO_PAYLOAD = {
        asOf: new Date().toISOString(),
        vix: { value: 0 },
        dxy: { value: 0 },
        usdjpy: { value: 0 },
        brent: { value: 0 },
      };

      const renderStatusPill = (state, text) => {
        const pill = document.getElementById('crash-mode');
        if (!pill) return;
        pill.classList.remove('live', 'error', 'loading', 'green', 'yellow', 'orange', 'red');
        pill.classList.add(state);
        pill.querySelector('span:nth-child(2)').textContent = text;
      };

      const setUpdated = (label) => {
        const el = document.getElementById('last-updated');
        if (!el) return;
        el.textContent = label;
      };

      const setNextRefresh = () => {
        const el = document.getElementById('next-refresh');
        if (!el) return;
        const diff = Math.max(0, nextRefreshAt - Date.now());
        const sec = Math.round(diff / 1000);
        el.textContent = sec === 1 ? 'Next refresh in 1s' : `Next refresh in ${sec}s`;
      };

      const activeSignalTemplates = [
        {
          id: 'vix',
          title: 'VIX (VIXM)',
          eval: (d) => {
            const raw = Number(d?.vix?.value);
            const value = Number.isFinite(raw) && raw > 0 ? raw : null;
            const level = Number.isFinite(value)
              ? value >= 30
                ? 'red'
                : value >= 27
                  ? 'orange'
                  : value >= 20
                    ? 'yellow'
                    : 'green'
              : 'green';
            return {
              level,
              value: Number.isFinite(value) ? `${value.toFixed(2)}` : 'N/A',
              detail: Number.isFinite(value)
                ? value >= 30
                  ? 'Watch out: capitulation risk'
                  : value >= 27
                    ? 'Watch out: panic band'
                    : value >= 20
                      ? 'Watch out: nerves rising'
                      : 'Calm: vol contained'
                : 'No data',
            };
          },
        },
        {
          id: 'brent',
          title: 'Brent (FRED DCOILBRENTEU)',
          eval: (d) => {
            const value = Number(d?.brent?.value);
            const level = Number.isFinite(value)
              ? value <= 55
                ? 'red'
                : value <= 58
                  ? 'orange'
                  : value <= 60
                    ? 'yellow'
                    : 'green'
              : 'green';
            return {
              level,
              value: Number.isFinite(value) ? `${value.toFixed(2)} USD` : 'N/A',
              detail: Number.isFinite(value)
                ? level === 'red'
                  ? 'Watch out: capitulation risk'
                  : level === 'orange'
                    ? 'Watch out: demand falling fast'
                    : level === 'yellow'
                      ? 'Watch out: slipping into yellow'
                      : 'Calm: above 60'
                : 'No data',
            };
          },
        },
      ];

      const activeFxTemplates = [
        {
          id: 'dxy',
          title: 'DXY (synthetic)',
          eval: (d) => {
            const price = Number(d?.dxy?.value);
            const level = Number.isFinite(price)
              ? price >= 107
                ? 'red'
                : price >= 105
                  ? 'orange'
                  : price >= 103
                    ? 'yellow'
                    : 'green'
              : 'green';
            return {
              level,
              value: Number.isFinite(price) ? `${price.toFixed(2)}` : 'N/A',
              detail: Number.isFinite(price)
                ? level === 'red'
                  ? 'Watch out: USD surge'
                  : level === 'orange'
                    ? 'Watch out: strong USD'
                    : level === 'yellow'
                      ? 'Watch out: USD firming'
                      : 'Calm: balanced'
                : 'No data',
            };
          },
        },
        {
          id: 'usdjpy',
          title: 'USD/JPY (USD/JPY)',
          eval: (d) => {
            const price = Number(d?.usdjpy?.value);
            const level = Number.isFinite(price)
              ? price >= 150
                ? 'orange'
                : price >= 148
                  ? 'yellow'
                  : 'green'
              : 'green';
            return {
              level,
              value: Number.isFinite(price) ? `${price.toFixed(2)}` : 'N/A',
              detail: Number.isFinite(price)
                ? level === 'orange'
                  ? 'Watch out: sharp spike'
                  : level === 'yellow'
                    ? 'Watch out: rising stress'
                    : 'Calm: orderly'
                : 'No data',
            };
          },
        },
      ];

      const crashModeLabel = (results) => {
        if (!results || !results.length) return { cls: 'loading', text: 'Waiting on signals' };
        const order = ['green', 'yellow', 'orange', 'red'];
        const worst = results.reduce((max, r) => (order.indexOf(r.level) > order.indexOf(max) ? r.level : max), 'green');
        if (worst === 'red') return { cls: 'red', text: 'Composite risk: RED' };
        if (worst === 'orange') return { cls: 'orange', text: 'Composite risk: ORANGE' };
        if (worst === 'yellow') return { cls: 'yellow', text: 'Composite risk: YELLOW' };
        return { cls: 'green', text: 'Composite risk: GREEN' };
      };

      const levelScore = (level) => {
        if (level === 'green') return 0.1;
        if (level === 'yellow') return 0.4;
        if (level === 'orange') return 0.7;
        if (level === 'red') return 0.95;
        return 0.0;
      };

      const updateDial = (results) => {
        const valueEl = document.getElementById('dial-value');
        const labelEl = document.getElementById('dial-label');
        const fillEl = document.getElementById('dial-fill');
        if (!valueEl || !labelEl || !fillEl) return;

        if (!results || !results.length) {
          valueEl.textContent = '--';
          fillEl.style.width = '0%';
          labelEl.textContent = 'Waiting on VIX';
          return;
        }

        const avg = results.reduce((sum, r) => sum + levelScore(r.level), 0) / results.length;
        const pct = Math.round(avg * 100);
        valueEl.textContent = (avg || 0).toFixed(2);
        fillEl.style.width = `${pct}%`;
        labelEl.textContent = 'Composite from live signals';
      };

      const renderSignals = (data) => {
        const container = document.getElementById('signal-list');
        if (!container) return;
        container.innerHTML = '';

        const liveResults = [...activeSignalTemplates, ...activeFxTemplates].map((tpl) => ({
          ...tpl.eval(data),
          id: tpl.id,
          title: tpl.title,
        }));

        liveResults.forEach((res) => {
          const card = document.createElement('div');
          card.className = `signal-card ${res.level}`;
          card.innerHTML = `
            <div class="signal-head">
              <div class="panel-title">${res.title}</div>
              <span class="signal-chip ${res.level}">${res.level.toUpperCase()}</span>
            </div>
            <div class="signal-meta">
              <div class="signal-value">${res.value}</div>
            </div>
          `;
          container.appendChild(card);
        });

        const overall = crashModeLabel(liveResults);
        renderStatusPill(overall.cls, overall.text);
        updateDial(liveResults);
      };

      // Keep symbol list minimal to reduce credits
      const VIX_SYMBOL = 'VIXM';
      const USDJPY_SYMBOL = 'USD/JPY';
      const DXY_WEIGHTS = [
        { symbol: 'EUR/USD', weight: -0.576 },
        { symbol: 'USD/JPY', weight: 0.136 },
        { symbol: 'GBP/USD', weight: -0.119 },
        { symbol: 'USD/CAD', weight: 0.091 },
        { symbol: 'USD/SEK', weight: 0.042 },
        { symbol: 'USD/CHF', weight: 0.036 },
      ];

      const fetchMarketDataClient = async () => {
        if (!LOCAL_TOKEN || LOCAL_TOKEN === 'YOUR_TWELVE_DATA_KEY') {
          throw new Error('No Twelve Data key');
        }
        const fetchPrice = async (symbol) => {
          const url = `https://api.twelvedata.com/price?symbol=${encodeURIComponent(symbol)}&apikey=${LOCAL_TOKEN}`;
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) {
            const text = await res.text();
            console.warn('Twelve Data price fetch failed', symbol, res.status, text);
            throw new Error(`Twelve Data price failed for ${symbol} (${res.status})`);
          }
          const json = await res.json();
          if (json && json.status === 'error') {
            throw new Error(json.message || `Twelve Data error for ${symbol}`);
          }
          const price = Number(json.price);
          if (!Number.isFinite(price)) {
            throw new Error(`No price for ${symbol}`);
          }
          return price;
        };

        const pairSymbols = Array.from(new Set([...DXY_WEIGHTS.map((p) => p.symbol), USDJPY_SYMBOL]));
        const pricePromises = pairSymbols.map((sym) => fetchPrice(sym));
        const [vixPrice, ...pairPrices] = await Promise.all([fetchPrice(VIX_SYMBOL), ...pricePromises]);

        const priceMap = {};
        pairSymbols.forEach((sym, idx) => {
          priceMap[sym] = pairPrices[idx];
        });

        const dxyValue = DXY_WEIGHTS.reduce((acc, { symbol, weight }) => {
          const px = Number(priceMap[symbol]);
          if (!Number.isFinite(px) || px <= 0) return acc;
          return acc * Math.pow(px, weight);
        }, 50.14348112);

        const usdJpyPrice = priceMap[USDJPY_SYMBOL];

        return {
          asOf: new Date().toISOString(),
          dxy: { value: Number.isFinite(dxyValue) ? dxyValue : null, change1d: null },
          vix: { value: vixPrice },
          usdjpy: { value: usdJpyPrice },
          brent: { value: 0 }, // Brent handled via server (FRED) only
        };
      };

      let lastLocalAttempt = 0;

      const fetchSignalsInner = async () => {
        const canUseLocal = LOCAL_TOKEN && !LOCAL_TOKEN.includes('YOUR');
        let hasApiRoute = !IS_STATIC; // allow API fetch on localhost as well

        // Prefer API (includes FRED Brent); fallback to local if API unavailable
        if (hasApiRoute) {
          try {
            const res = await fetch(ENDPOINT, { cache: 'no-store' });
            if (!res.ok) {
              if (res.status === 404) {
                hasApiRoute = false; // no API route; skip further API attempts this cycle
              }
              if (res.status === 429) throw new Error('Rate limited');
              throw new Error('Bad response');
            }
            const data = await res.json();
            renderSignals(data);
            renderStatusPill('live', 'Updated');
            setUpdated(`Updated ${new Date().toLocaleTimeString()}`);
            nextRefreshAt = Date.now() + POLL_INTERVAL_MS;
            setNextRefresh();
            return;
          } catch (err) {
            console.warn('API fetch failed', err);
            // fall through to local if possible
          }
        }

        if (canUseLocal) {
          const now = Date.now();
          if (now - lastLocalAttempt < 65000) {
            console.warn('Skipping local fetch to avoid rate limit');
          } else {
            lastLocalAttempt = now;
            try {
              const data = await fetchMarketDataClient();
              renderSignals(data);
              renderStatusPill('live', 'Updated (local Twelve Data)');
              setUpdated(`Updated ${new Date().toLocaleTimeString()}`);
              nextRefreshAt = Date.now() + POLL_INTERVAL_MS;
              setNextRefresh();
              return;
            } catch (errLocal) {
              console.warn('Local Twelve Data fetch failed', errLocal);
            }
          }
        }

        if (!hasApiRoute && !canUseLocal) {
          setUpdated('No data sources available; not able to fetch data');
          renderSignals(ZERO_PAYLOAD);
          renderStatusPill('error', 'Not able to fetch data');
          nextRefreshAt = Date.now() + POLL_INTERVAL_MS;
          setNextRefresh();
          return;
        }

        // Final fallback: zeros
        renderSignals(ZERO_PAYLOAD);
        renderStatusPill('error', 'Not able to fetch data');
        setUpdated('Not able to fetch data');
        nextRefreshAt = Date.now() + POLL_INTERVAL_MS;
        setNextRefresh();
      };

      const fetchSignals = async () => fetchSignalsInner();

      setUpdated(IS_STATIC && LOCAL_TOKEN && !LOCAL_TOKEN.includes('YOUR') ? 'Loading from Twelve Data...' : 'Waiting for data...');
      fetchSignals();
      setInterval(fetchSignals, POLL_INTERVAL_MS);
      setInterval(setNextRefresh, 1000);
    </script>
  </body>
</html>
